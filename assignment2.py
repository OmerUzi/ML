#################################
#Omer Uziel
#################################

import numpy as np
import matplotlib.pyplot as plt
import intervals


class Assignment2(object):
    """Assignment 2 skeleton.

    Please use these function signatures for this assignment and submit this file, together with the intervals.py.
    """

    def sample_from_D(self, m):
        """Sample m data samples from D.
        Input: m - an integer, the size of the data sample.

        Returns: np.ndarray of shape (m,2) :
                A two dimensional array of size m that contains the pairs where drawn from the distribution P.
        """
        # Create a list xs with m floats in [0,1]
        xs = np.sort(np.random.uniform(0, 1, m)).tolist()  # Convert the array to a list

        # Create a list ys with m labels generated by xs values
        ys = []
        for x in xs:
            if self.probability(x) > np.random.rand():
                ys.append(1)
            else:
                ys.append(0)
        return xs, ys


    def experiment_m_range_erm(self, m_first, m_last, step, k, T):
        """Runs the ERM algorithm.
        Calculates the empirical error and the true error.
        Plots the average empirical and true errors.
        Input: m_first - an integer, the smallest size of the data sample in the range.
               m_last - an integer, the largest size of the data sample in the range.
               step - an integer, the difference between the size of m in each loop.
               k - an integer, the maximum number of intervals.
               T - an integer, the number of times the experiment is performed.

        Returns: np.ndarray of shape (n_steps,2).
            A two dimensional array that contains the average empirical error
            and the average true error for each m in the range accordingly.
        """
        empirical_errors = []
        true_errors = []

        # Iterate over sample sizes m in the given range
        for m in range(m_first, m_last + 1, step):
            empirical_error_list = []
            true_error_list = []

            # Run the experiment T times for each sample size m
            for i in range(T):
                xs, ys = self.sample_from_D(m)
                
                # Find the best intervals using the ERM algorithm
                best_intervals, besterror = intervals.find_best_interval(xs, ys, k)

                # Calculate empirical error (on the sample)
                empirical_error = besterror / m 
                empirical_error_list.append(empirical_error)

                # Calculate true error (on the entire distribution)
                true_error = self.calculate_true_error(best_intervals)
                true_error_list.append(true_error)

            # Average the errors over T runs
            empirical_errors.append(np.mean(empirical_error_list))
            true_errors.append(np.mean(true_error_list))

        # Convert the results into a 2D array
        results = np.column_stack((empirical_errors, true_errors))

        # Plot the results
        self.plot_errors(np.arange(m_first, m_last + 1, step), results
                         ,"Empirical vs True Error for different M","Sample Size (m)")
        

    def experiment_k_range_erm(self, m, k_first, k_last, step):
        """Finds the best hypothesis for k= 1,2,...,10.
        Plots the empirical and true errors as a function of k.
        Input: m - an integer, the size of the data sample.
               k_first - an integer, the maximum number of intervals in the first experiment.
               m_last - an integer, the maximum number of intervals in the last experiment.
               step - an integer, the difference between the size of k in each experiment.

        Returns: The best k value (an integer) according to the ERM algorithm.
        """
        empirical_errors = []
        true_errors = []
        xs, ys = self.sample_from_D(m)

        # Iterate over sample sizes k in the given range
        for k in range(k_first, k_last + 1, step):
            
            # Find the best intervals using the ERM algorithm
            best_intervals, besterror = intervals.find_best_interval(xs, ys, k)

            # Calculate empirical error (on the sample)
            empirical_error = besterror / m 
            empirical_errors.append(empirical_error)

            # Calculate true error 
            true_error = self.calculate_true_error(best_intervals)
            true_errors.append(true_error)


        # Convert the results into a 2D array
        results = np.column_stack((empirical_errors, true_errors))

        # Plot the results
        self.plot_errors(np.arange(k_first, k_last + 1, step), results
                         ,"Empirical vs True Error for different K","Max number of intervals (k)")
        

    def experiment_k_range_srm(self, m, k_first, k_last, step):
        """Run the experiment in (c).
        Plots additionally the penalty for the best ERM hypothesis.
        and the sum of penalty and empirical error.
        Input: m - an integer, the size of the data sample.
               k_first - an integer, the maximum number of intervals in the first experiment.
               m_last - an integer, the maximum number of intervals in the last experiment.
               step - an integer, the difference between the size of k in each experiment.

        Returns: The best k value (an integer) according to the SRM algorithm.
        """
        empirical_errors = []
        true_errors = []
        penalty_list = []
        sum_list = []

        xs, ys = self.sample_from_D(m)

        # Iterate over sample sizes k in the given range
        for k in range(k_first, k_last + 1, step):
            
            # Find the best intervals using the ERM algorithm
            best_intervals, besterror = intervals.find_best_interval(xs, ys, k)

            # Calculate empirical error 
            empirical_error = besterror / m 
            empirical_errors.append(empirical_error)

            # Calculate true error 
            true_error = self.calculate_true_error(best_intervals)
            true_errors.append(true_error)
            penalty = 2 * np.sqrt(((k + 1) + np.log(2 * (k**2) / 0.1)) / m)
            penalty_list.append(penalty)
            sum_list.append(penalty + empirical_error)


        # Plot the results
        positions = np.arange(k_first, k_last + 1, step)
        # Plotting the data
        plt.plot(positions, empirical_errors, label="Empirical Error", marker="o")
        plt.plot(positions, true_errors, label="True Error", marker="s")
        plt.plot(positions, penalty_list, label="Penalty", marker="^")
        plt.plot(positions, sum_list, label="Empirical Error + Penalty", marker="d")

        # Adding labels, title, legend, and grid
        plt.xlabel("Max number of intervals (k)")
        plt.ylabel("Error")
        plt.title("SRM")
        plt.legend()
        plt.grid(True)

        # Display the plot
        plt.show()


    def cross_validation(self, m):
        """Finds a k that gives a good test error.
        Input: m - an integer, the size of the data sample.

        Returns: The best k value (an integer) found by the cross validation algorithm.
        """
       
        validation_errors = []
        xs, ys = self.sample_from_D(int(0.8*m))
        validation_xs, validation_ys = self.sample_from_D(int(0.2*m))

        for k in range(1, 11):
            # Find the best intervals using the ERM algorithm
            best_intervals, besterror = intervals.find_best_interval(xs, ys, k)

            # Calculate validation errors error
            counter = 0 
            for i in range(len(validation_xs)):
                if (self.is_in_intervals(validation_xs[i],best_intervals) != validation_ys[i]):  counter += 1
            validation_errors.append(counter/len(validation_xs))

        # Plot the results
        positions = np.arange(1,11)
        # Plotting the data
        plt.plot(positions, validation_errors, label="Validation Error", marker="o")

        # Adding labels, title, legend, and grid
        plt.xlabel("Max number of intervals (k)")
        plt.ylabel("Error")
        plt.title("Cross validation")
        plt.legend()
        plt.grid(True)

        # Display the plot
        plt.show()

        min_value = min(validation_errors)
        min_index = validation_errors.index(min_value)

        print(f"Minimum validation Error: {min_value}")
        print(f"Best K is: {min_index + 1}")
    

    # Place for additional methods
    def calculate_true_error(self, intervals):
        # Define the union intervals
        union_intervals = np.array([[0, 0.2], [0.4, 0.6], [0.8, 1]])
        
        # Calculate total length of input intervals
        total_length = sum(u - l for l, u in intervals)
        
        # Calculate common length
        common_length = 0
        for l, u in intervals:
            for l_union, u_union in union_intervals:
                overlap_start = max(l, l_union)
                overlap_end = min(u, u_union)
                if overlap_start < overlap_end:
                    common_length += overlap_end - overlap_start
        
        # calculate the true error
        error = (
            common_length * 0.2 + 
            ((total_length - common_length) * 0.9) + 
            ((0.6 - common_length) * 0.8) + 
            ((0.4 - total_length + common_length) * 0.1) 
        )
        return error

    def probability(self,x):
        if (0 <= x <= 0.2) or (0.4 <= x <= 0.6) or (0.8 <= x <= 1):
            return 0.8
        else:
            return 0.1

    def is_in_intervals(self, x, intervals):
        for l, u in intervals:
            if l <= x <= u:
                return 1  # x is within the interval
        return 0  # x is not within any of the intervals

    def plot_errors(self, m_values, errors, title, axis):
        """Plot the empirical and true errors."""
        plt.plot(m_values, errors[:, 0], label="Empirical Error", marker="o")
        plt.plot(m_values, errors[:, 1], label="True Error", marker="s")
        plt.xlabel(axis)
        plt.ylabel('Error')
        plt.title(title)
        plt.legend()
        plt.grid(True)
        plt.show()


if __name__ == '__main__':
    ass = Assignment2()
    ass.experiment_m_range_erm(10, 100, 5, 3, 100)
    ass.experiment_k_range_erm(1500, 1, 10, 1)
    ass.experiment_k_range_srm(1500, 1, 10, 1)
    ass.cross_validation(1500)

